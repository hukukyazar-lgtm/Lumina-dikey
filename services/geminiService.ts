import { GoogleGenAI, Type, Modality } from '@google/genai';
import { turkishWordList, englishWordList } from './wordList';
import type { Language, WordLength, ButtonStructure, ThemePalette } from '../types';

// NOTE: It is assumed that process.env.API_KEY is available in the execution environment.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY as string });

/**
 * Fetches a word challenge from local lists.
 * While this file is named geminiService, using a generative AI for this specific task
 * is inefficient and can lead to lower-quality, less predictable word sets compared to
 * the curated local lists. This implementation prioritizes performance and gameplay quality.
 * A sample Gemini-based implementation is commented out below for reference.
 */
export const fetchWordChallenge = async (
  wordLength: WordLength,
  language: Language,
  usedWords: Set<string>
): Promise<{ correctWord: string; incorrectWords: string[] }> => {
  const wordList = language === 'tr' ? turkishWordList : englishWordList;
  const possibleSets = wordList[wordLength];

  if (!possibleSets) {
      throw new Error(`No word list available for length ${wordLength} in ${language}`);
  }

  let availableSets = possibleSets.filter(wordSet => !usedWords.has(wordSet[0]));
  
  // If all words for this length have been used, reset the used words set for this length.
  if (availableSets.length === 0) {
      const wordsOfLength = new Set(possibleSets.map(set => set[0]));
      usedWords.forEach(word => {
          if (wordsOfLength.has(word)) {
              usedWords.delete(word);
          }
      });
      availableSets = possibleSets;
  }
  
  const selectedSet = availableSets[Math.floor(Math.random() * availableSets.length)];
  const correctWord = selectedSet[0];
  const incorrectWords = selectedSet.slice(1);

  usedWords.add(correctWord);

  return { correctWord, incorrectWords };
};

export const generateImageFromPrompt = async (prompt: string): Promise<string> => {
    const response = await ai.models.generateImages({
        model: 'imagen-4.0-generate-001',
        prompt,
        config: {
          numberOfImages: 1,
          outputMimeType: 'image/jpeg',
          aspectRatio: '1:1',
        },
    });

    const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
    return `data:image/jpeg;base64,${base64ImageBytes}`;
};

export const describeImage = async (base64ImageData: string, mimeType: string): Promise<string> => {
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: {
            parts: [
                {
                    inlineData: { data: base64ImageData, mimeType },
                },
                { text: 'Describe this image in a short, creative phrase suitable for an image generation prompt.' },
            ],
        },
    });
    return response.text;
};

export const editImage = async (prompt: string, base64ImageData: string, mimeType: string): Promise<string> => {
    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash-image',
        contents: {
            parts: [
                {
                    inlineData: { data: base64ImageData, mimeType },
                },
                { text: prompt },
            ],
        },
        config: {
            responseModalities: [Modality.IMAGE],
        },
    });

    for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
            const base64ImageBytes: string = part.inlineData.data;
            return `data:${part.inlineData.mimeType};base64,${base64ImageBytes}`;
        }
    }
    throw new Error('No image was generated by the model.');
};

export const generateDetailedPrompt = async (idea: string, style: string, mood: string, language: Language): Promise<string> => {
    const langName = language === 'tr' ? 'Turkish' : 'English';
    const prompt = `Create a detailed, artistic image generation prompt in ${langName}.
    - Base Idea: "${idea}"
    - Art Style: "${style}"
    - Mood: "${mood}"
    Combine these into a single, flowing sentence or two. Focus on visual details like colors, lighting, and composition. The output must only be the prompt text itself.`;

    const response = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
    });
    return response.text.trim();
};

export const generateButtonStructureFromPrompt = async (prompt: string): Promise<Partial<ButtonStructure>> => {
    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash",
        contents: `Analyze the following description of a button's physical appearance and extract its structural properties. Description: "${prompt}"`,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                    borderRadius: { type: Type.INTEGER, description: 'Corner roundness in pixels, from 0 (sharp) to 50 (very round).' },
                    shadowDepth: { type: Type.INTEGER, description: 'The perceived depth of the button\'s shadow in pixels, from 0 (flat) to 10 (deep).' },
                    highlightIntensity: { type: Type.NUMBER, description: 'The brightness of the top-edge highlight, from 0 (none) to 1 (very bright).' },
                    surface: { type: Type.STRING, description: 'The material surface, either "matte", "glossy", or "metallic".' }
                }
            }
        },
    });

    return JSON.parse(response.text.trim()) as Partial<ButtonStructure>;
};

export const generateThemePaletteFromPrompt = async (prompt: string): Promise<ThemePalette> => {
    const response = await ai.models.generateContent({
        model: "gemini-2.5-pro", // Using a more powerful model for better color theory and design
        contents: `Generate a vibrant, accessible UI color theme palette based on the following concept: "${prompt}". Provide hex codes for all specified CSS variables. Ensure high contrast and a cohesive, visually appealing result suitable for a sci-fi game UI.`,
        config: {
            responseMimeType: "application/json",
            responseSchema: {
                type: Type.OBJECT,
                properties: {
                  '--brand-bg-gradient-start': { type: Type.STRING, description: 'Dark start color for background gradient.' },
                  '--brand-bg-gradient-end': { type: Type.STRING, description: 'Dark end color for background gradient.' },
                  '--brand-primary': { type: Type.STRING, description: 'Primary UI panel color (should be semi-transparent, e.g., rgba(r,g,b,a)).' },
                  '--brand-secondary': { type: Type.STRING, description: 'Secondary UI panel color (should be semi-transparent, e.g., rgba(r,g,b,a)).' },
                  '--brand-light': { type: Type.STRING, description: 'Main text color.' },
                  '--brand-accent': { type: Type.STRING, description: 'Primary accent color (e.g., for errors, danger).' },
                  '--brand-accent-secondary': { type: Type.STRING, description: 'Secondary accent color (e.g., for highlights, info).' },
                  '--brand-warning': { type: Type.STRING, description: 'Warning color (e.g., for timers, alerts).' },
                  '--brand-correct': { type: Type.STRING, description: 'Success/correct action color.' },
                  '--brand-tertiary': { type: Type.STRING, description: 'A lighter shade of the primary accent.' },
                  '--brand-quaternary': { type: Type.STRING, description: 'A lighter shade of the secondary accent.' },
                  '--brand-accent-shadow': { type: Type.STRING, description: 'A darker shade for the primary accent shadow.' },
                  '--brand-accent-secondary-shadow': { type: Type.STRING, description: 'A darker shade for the secondary accent shadow.' },
                  '--brand-warning-shadow': { type: Type.STRING, description: 'A darker shade for the warning shadow.' },
                  '--brand-correct-shadow': { type: Type.STRING, description: 'A darker shade for the correct shadow.' },
                  '--shadow-color-strong': { type: Type.STRING, description: 'Strong shadow color (e.g., rgba(0,0,0,0.2)).' },
                  '--bevel-shadow-dark': { type: Type.STRING, description: 'Dark bevel highlight color (e.g., rgba(r,g,b,a)).' },
                  '--bevel-shadow-light': { type: Type.STRING, description: 'Light bevel highlight color (e.g., rgba(r,g,b,a)).' },
                  '--brand-accent-secondary-glow': { type: Type.STRING, description: 'Glow color for the secondary accent (e.g., rgba(r,g,b,a)).' },
                  '--brand-accent-glow': { type: Type.STRING, description: 'Glow color for the primary accent (e.g., rgba(r,g,b,a)).' },
                  '--brand-warning-glow': { type: Type.STRING, description: 'Glow color for the warning accent (e.g., rgba(r,g,b,a)).' },
                  '--cube-face-bg': { type: Type.STRING, description: 'Background color for letter cubes (can be a gradient).' },
                  '--cube-face-border': { type: Type.STRING, description: 'Border color for letter cubes.' },
                  '--cube-face-text-color': { type: Type.STRING, description: 'Text color for letter cubes.' },
                  '--cube-face-text-shadow': { type: Type.STRING, description: 'Text shadow for letter cubes (e.g., "0 0 8px #color").' },
                }
            }
        },
    });

    return JSON.parse(response.text.trim()) as ThemePalette;
};
